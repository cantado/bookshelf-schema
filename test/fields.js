// Generated by CoffeeScript 2.3.2
var Bookshelf, CheckIt, F, Schema, init;

Bookshelf = require('bookshelf');

CheckIt = require('checkit');

Schema = require('../src/');

init = require('./init');

F = require('../src/fields');

describe("Fields", function() {
  var db, define;
  this.timeout(3000);
  db = null;
  define = function(fields) {
    var User;
    return User = (function() {
      class User extends db.Model {};

      User.prototype.tableName = 'users';

      User.schema(fields);

      return User;

    }).call(this);
  };
  before(function() {
    db = init.init();
    return init.users();
  });
  afterEach(function() {
    return init.truncate('users');
  });
  describe('Any field', function() {
    return it('may be required', co(function*() {
      var User;
      User = define([
        F.StringField('username',
        {
          required: true
        })
      ]);
      User.__bookshelf_schema.validations.username.should.deep.equal(['string', 'required']);
      return (yield [
        new User().validate().should.be.rejected,
        new User({
          username: 'alice'
        }).validate().should.be.fulfilled
      ]);
    }));
  });
  describe('StringField', function() {
    it('validates min_length and max_length', co(function*() {
      var User;
      User = define([
        F.StringField('username',
        {
          min_length: 5,
          max_length: 10
        })
      ]);
      User.__bookshelf_schema.validations.username.should.deep.equal(['string', 'minLength:5', 'maxLength:10']);
      return (yield [
        new User({
          username: 'foo'
        }).validate().should.be.rejected,
        new User({
          username: 'Some nickname that is longer then 10 characters'
        }).validate().should.be.rejected,
        new User({
          username: 'justfine'
        }).validate().should.be.fulfilled
      ]);
    }));
    return it('uses additional names for length restrictions', function() {
      var User;
      User = define([
        F.StringField('username',
        {
          minLength: 5,
          maxLength: 10
        })
      ]);
      return User.__bookshelf_schema.validations.username.should.deep.equal(['string', 'minLength:5', 'maxLength:10']);
    });
  });
  describe('EmailField', function() {
    return it('validates email', co(function*() {
      var User;
      User = define([F.EmailField('email')]);
      User.__bookshelf_schema.validations.email.should.deep.equal(['string', 'email']);
      return (yield [
        new User({
          email: 'foo'
        }).validate().should.be.rejected,
        new User({
          email: 'foo@bar.com'
        }).validate().should.be.fulfilled
      ]);
    }));
  });
  describe('EncryptedStringField', function() {
    it('save its value encrypted', co(function*() {
      var User, alice;
      User = define([
        F.EncryptedStringField('password',
        {
          iterations: 1
        })
      ]);
      alice = (yield new User({
        password: 'password'
      }).save());
      alice.password.plain.should.equal('password');
      alice = (yield User.forge({
        id: alice.id
      }).fetch());
      expect(alice.password.plain).to.be.null;
      return alice.password.verify('password').should.become(true);
    }));
    it('saves new value encrypted', co(function*() {
      var User, alice;
      User = define([
        F.EncryptedStringField('password',
        {
          iterations: 1
        })
      ]);
      alice = (yield new User({
        password: 'password'
      }).save());
      alice.password = 'password2';
      yield alice.save();
      alice = (yield User.forge({
        id: alice.id
      }).fetch());
      return alice.password.verify('password2').should.become.true;
    }));
    it("doesn't reencrypt it on save", co(function*() {
      var User, alice, check;
      User = define([
        F.EncryptedStringField('password',
        {
          iterations: 1
        })
      ]);
      alice = (yield new User({
        password: 'password'
      }).save());
      alice = (yield User.forge({
        id: alice.id
      }).fetch());
      check = alice.password.encrypted;
      alice.set('username', 'alice');
      yield alice.save();
      alice = (yield User.forge({
        id: alice.id
      }).fetch());
      return alice.password.encrypted.should.equal(check);
    }));
    return it('validates length against plain value', co(function*() {
      var User, alice;
      User = define([
        F.EncryptedStringField('password',
        {
          iterations: 1,
          minLength: 8,
          maxLength: 10
        })
      ]);
      yield [
        new User({
          password: 'foo'
        }).validate().should.be.rejected,
        new User({
          password: 'password'
        }).validate().should.be.fulfilled,
        new User({
          password: 'password1234567890'
        }).validate().should.be.rejected
      ];
      alice = (yield new User({
        password: 'password'
      }).save());
      alice = (yield User.forge({
        id: alice.id
      }).fetch());
      return (yield alice.validate().should.be.fulfilled);
    }));
  });
  describe('IntField', function() {
    it('validates integers', co(function*() {
      var User;
      User = define([F.IntField('code')]);
      User.__bookshelf_schema.validations.code.should.deep.equal(['integer']);
      return (yield [
        new User({
          code: 'foo'
        }).validate().should.be.rejected,
        new User({
          code: '10foo'
        }).validate().should.be.rejected,
        new User({
          code: 10.5
        }).validate().should.be.rejected,
        new User({
          code: 10
        }).validate().should.be.fulfilled,
        new User({
          code: '10'
        }).validate().should.be.fulfilled,
        new User({
          code: '-10'
        }).validate().should.be.fulfilled
      ]);
    }));
    it('validates natural', co(function*() {
      var User;
      User = define([
        F.IntField('code',
        {
          natural: true
        })
      ]);
      User.__bookshelf_schema.validations.code.should.deep.equal(['integer', 'natural']);
      return (yield [
        new User({
          code: 10
        }).validate().should.be.fulfilled,
        new User({
          code: -10
        }).validate().should.be.rejected,
        new User({
          code: '-10'
        }).validate().should.be.rejected
      ]);
    }));
    it('validates bounds', co(function*() {
      var User;
      User = define([
        F.IntField('code',
        {
          greater_than: 1,
          less_than: 10
        })
      ]);
      User.__bookshelf_schema.validations.code.should.deep.equal(['integer', 'greaterThan:1', 'lessThan:10']);
      return (yield [
        new User({
          code: 5
        }).validate().should.be.fulfilled,
        new User({
          code: 1
        }).validate().should.be.rejected,
        new User({
          code: 10
        }).validate().should.be.rejected
      ]);
    }));
    return it('keeps nulls', co(function*() {
      var User, user;
      User = define([F.IntField('code')]);
      user = (yield new User({
        code: null
      }).save());
      expect(user.code).to.be.null;
      user = (yield User.forge({
        id: user.id
      }).fetch());
      return expect(user.code).to.be.null;
    }));
  });
  describe('FloatField', function() {
    it('validates floats', co(function*() {
      var User;
      User = define([F.FloatField('code')]);
      User.__bookshelf_schema.validations.code.should.deep.equal(['numeric']);
      return (yield [
        new User({
          code: 'foo'
        }).validate().should.be.rejected,
        new User({
          code: '10foo'
        }).validate().should.be.rejected,
        new User({
          code: 10.5
        }).validate().should.be.fulfilled,
        new User({
          code: 10
        }).validate().should.be.fulfilled,
        new User({
          code: '10.5'
        }).validate().should.be.fulfilled,
        new User({
          code: '-10.5'
        }).validate().should.be.fulfilled
      ]);
    }));
    return it('keeps nulls', co(function*() {
      var User, user;
      User = define([F.FloatField('code')]);
      user = (yield new User({
        code: null
      }).save());
      expect(user.code).to.be.null;
      user = (yield User.forge({
        id: user.id
      }).fetch());
      return expect(user.code).to.be.null;
    }));
  });
  describe('BooleanField', function() {
    return it('stores boolean values', co(function*() {
      var User, user;
      User = define([F.BooleanField('flag')]);
      user = (yield new User({
        flag: 'some string'
      }).save());
      user = (yield new User({
        id: user.id
      }).fetch());
      return user.flag.should.be.true;
    }));
  });
  describe('DateTimeField', function() {
    it('stores Date objects', co(function*() {
      var User, date, user;
      User = define([F.DateTimeField('last_login')]);
      date = new Date('2013-09-25T15:00:00.000Z');
      user = (yield new User({
        last_login: date
      }).save());
      user = (yield new User({
        id: user.id
      }).fetch());
      user.last_login.should.be.an.instanceof(Date);
      return user.last_login.toISOString().should.equal(date.toISOString());
    }));
    it('validates date', co(function*() {
      var User;
      User = define([F.DateTimeField('last_login')]);
      return (yield [
        new User({
          last_login: new Date()
        }).validate().should.be.fulfilled,
        new User({
          last_login: new Date().toUTCString()
        }).validate().should.be.fulfilled,
        new User({
          last_login: '1/1/1'
        }).validate().should.be.fulfilled,
        new User({
          last_login: 'foobar'
        }).validate().should.be.rejected
      ]);
    }));
    return it('keeps nulls', co(function*() {
      var User, user;
      User = define([F.DateTimeField('last_login')]);
      user = (yield new User({
        last_login: null
      }).save());
      expect(user.last_login).to.be.null;
      user = (yield User.forge({
        id: user.id
      }).fetch());
      return expect(user.last_login).to.be.null;
    }));
  });
  describe('DateField', function() {
    var truncate_date;
    truncate_date = function(d) {
      return new Date(d.getFullYear(), d.getMonth(), d.getDate());
    };
    it('stores Date objects', co(function*() {
      var User, date, user;
      User = define([F.DateField('birth_date')]);
      date = new Date('2013-09-25T15:00:00.000Z');
      user = (yield new User({
        birth_date: date
      }).save());
      user = (yield new User({
        id: user.id
      }).fetch());
      user.birth_date.should.be.an.instanceof(Date);
      return user.birth_date.toISOString().should.equal(truncate_date(date).toISOString());
    }));
    it('validates date', co(function*() {
      var User;
      User = define([F.DateField('birth_date')]);
      return (yield [
        new User({
          birth_date: new Date()
        }).validate().should.be.fulfilled,
        new User({
          birth_date: new Date().toUTCString()
        }).validate().should.be.fulfilled,
        new User({
          birth_date: '1/1/1'
        }).validate().should.be.fulfilled,
        new User({
          birth_date: 'foobar'
        }).validate().should.be.rejected
      ]);
    }));
    return it('keeps nulls', co(function*() {
      var User, user;
      User = define([F.DateField('birth_date')]);
      user = (yield new User({
        birth_date: null
      }).save());
      expect(user.birth_date).to.be.null;
      user = (yield User.forge({
        id: user.id
      }).fetch());
      return expect(user.birth_date).to.be.null;
    }));
  });
  describe('JSONField', function() {
    it('stores JSON objects', co(function*() {
      var User, data, user;
      User = define([F.JSONField('additional_data')]);
      data = {
        nickname: 'bogus',
        interests: ['nodejs', 'photography', 'tourism']
      };
      user = (yield new User({
        additional_data: data
      }).save());
      user = (yield new User({
        id: user.id
      }).fetch());
      return user.additional_data.should.deep.equal(data);
    }));
    return it('validates JSON', co(function*() {
      var User;
      User = define([F.JSONField('additional_data')]);
      return (yield [
        new User({
          additional_data: {
            foo: 'bar'
          }
        }).validate().should.be.fulfilled,
        new User({
          additional_data: JSON.stringify({
            foo: 'bar'
          })
        }).validate().should.be.fulfilled,
        new User({
          additional_data: 42
        }).validate().should.be.rejected,
        new User({
          additional_data: 'not a json'
        }).validate().should.be.rejected
      ]);
    }));
  });
  return describe('Virtuals and aliases', function() {
    it('sets column value through alias', function() {
      var User, alice;
      User = define([
        F.StringField('login',
        {
          column: 'username'
        })
      ]);
      alice = new User({
        login: 'alice'
      });
      return alice.get('username').should.equal('alice');
    });
    it('validates aliased fields', co(function*() {
      var User;
      User = define([
        F.StringField('login',
        {
          column: 'username',
          min_length: 5,
          max_length: 10
        })
      ]);
      User.__bookshelf_schema.validations.should.have.property('login');
      User.__bookshelf_schema.validations.login.should.deep.equal(['string', 'minLength:5', 'maxLength:10']);
      return (yield [
        new User({
          login: 'foo'
        }).validate().should.be.rejected,
        new User({
          login: 'Some nickname that is longer then 10 characters'
        }).validate().should.be.rejected,
        new User({
          login: 'justfine'
        }).validate().should.be.fulfilled
      ]);
    }));
    it('saves model with alias', co(function*() {
      var User, alice;
      User = define([
        F.StringField('login',
        {
          column: 'username'
        })
      ]);
      alice = (yield User.forge({
        login: 'alice'
      }).save());
      alice = (yield User.forge({
        id: alice.id
      }).fetch());
      return alice.login.should.equal('alice');
    }));
    it('saves model with aliased field passed as an attribute', co(function*() {
      var User, alice;
      User = define([
        F.StringField('login',
        {
          column: 'username'
        })
      ]);
      alice = (yield User.forge().save({
        login: 'alice'
      }));
      alice = (yield User.forge({
        id: alice.id
      }).fetch());
      alice.login.should.equal('alice');
      yield alice.save('login', 'annie');
      alice = (yield User.forge({
        id: alice.id
      }).fetch());
      return alice.login.should.equal('annie');
    }));
    it('saves model with aliased field using patch', co(function*() {
      var User, alice;
      User = define([
        F.StringField('login',
        {
          column: 'username'
        })
      ]);
      alice = (yield User.forge({
        login: 'alice'
      }).save());
      yield User.forge({
        id: alice.id
      }).save({
        login: 'annie'
      }, {
        patch: true
      });
      alice = (yield User.forge({
        id: alice.id
      }).fetch());
      return alice.login.should.equal('annie');
    }));
    return it('uses aliases in json', co(function*() {
      var User, alice;
      User = define([
        F.StringField('login',
        {
          column: 'username'
        })
      ]);
      alice = (yield User.forge({
        login: 'alice'
      }).save());
      alice.toJSON().should.have.property('login');
      return alice.toJSON().login.should.equal('alice');
    }));
  });
});
