// Generated by CoffeeScript 2.3.2
var Bookshelf, Listen, Schema, init;

Bookshelf = require('bookshelf');

Schema = require('../lib/');

init = require('./init');

Listen = require('../lib/listen');

describe('Listen', function() {
  var User, db;
  this.timeout(3000);
  db = null;
  User = null;
  before(function() {
    db = init.init();
    return init.users();
  });
  beforeEach(function() {
    return User = (function() {
      class User extends db.Model {};

      User.prototype.tableName = 'users';

      return User;

    }).call(this);
  });
  it('can add functions as listeners', co(function*() {
    var f1, f2, f3;
    f1 = spy();
    f2 = spy();
    f3 = spy();
    User.schema([Listen('saved', f1, f2)]);
    yield new User({
      username: 'alice'
    }).save();
    f1.should.be.called.once;
    f2.should.be.called.once;
    return f3.should.not.be.called();
  }));
  it('can add listeners by name', co(function*() {
    var u;
    User.prototype.f1 = spy();
    User.prototype.f2 = spy();
    User.prototype.f3 = spy();
    User.schema([Listen('saved', 'f1', 'f2')]);
    u = (yield new User({
      username: 'alice'
    }).save());
    u.f1.should.be.called.once;
    u.f2.should.be.called.once;
    return u.f3.should.not.be.called();
  }));
  it('can check for a condition', co(function*() {
    var f1, f2, f3, f4;
    f1 = spy();
    f2 = spy();
    f3 = spy();
    f4 = spy();
    User.prototype.checkTrue = function() {
      return true;
    };
    User.prototype.checkFalse = function() {
      return false;
    };
    User.schema([
      Listen('saved',
      f1,
      {
        condition: function() {
          return true;
        }
      }),
      Listen('saved',
      f2,
      {
        condition: function() {
          return false;
        }
      }),
      Listen('saved',
      f3,
      {
        condition: 'checkTrue'
      }),
      Listen('saved',
      f3,
      {
        condition: 'checkFalse'
      })
    ]);
    yield new User({
      username: 'alice'
    }).save();
    f1.should.have.been.called.once;
    f3.should.have.been.called.once;
    f2.should.not.have.been.called();
    return f4.should.not.have.been.called();
  }));
  it('allows listeners to return Promise and waits for them', co(function*() {
    var f1, f2, f3, order;
    order = [];
    f1 = spy(function() {
      return order.push('f1');
    });
    f3 = spy(function() {
      return order.push('f3');
    });
    f2 = spy(function() {
      return new Promise(function(resolve, reject) {
        return setTimeout(function() {
          f1.should.have.been.called.once;
          f3.should.not.have.been.called();
          order.push('f2');
          return resolve();
        }, 30);
      });
    });
    User.schema([Listen('saving', f1, f2), Listen('saved', f3)]);
    yield new User({
      username: 'alice'
    }).save();
    f1.should.have.been.called.once;
    f2.should.have.been.called.once;
    f3.should.have.been.called.once;
    return order.should.deep.equal(['f1', 'f2', 'f3']);
  }));
  return it('breaks callback chain on rejected promise', co(function*() {
    var f1, f2;
    f1 = spy(function() {
      return Promise.reject();
    });
    f2 = spy();
    User.schema([Listen('saving', f1), Listen('saved', f2)]);
    yield new User({
      username: 'alice'
    }).save().should.be.rejected;
    f1.should.have.been.called.once;
    return f2.should.not.have.been.called();
  }));
});
