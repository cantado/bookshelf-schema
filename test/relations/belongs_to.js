// Generated by CoffeeScript 2.3.2
var BelongsTo, Bookshelf, EmailField, Fields, HasMany, IntField, Relations, Schema, StringField, init;

Bookshelf = require('bookshelf');

Schema = require('../../src/');

init = require('../init');

Fields = require('../../src/fields');

Relations = require('../../src/relations');

({StringField, IntField, EmailField} = Fields);

({HasMany, BelongsTo} = Relations);

describe("Relations", function() {
  var Inviter, Photo, User, db, fixtures;
  this.timeout(3000);
  db = null;
  User = null;
  Photo = null;
  Inviter = null;
  fixtures = {
    alice: co(function*() {
      var alice, photos;
      alice = (yield new User({
        username: 'alice'
      }).save());
      photos = (yield [
        new Photo({
          filename: 'photo1.jpg',
          user_id: alice.id
        }).save(),
        new Photo({
          filename: 'photo2.jpg',
          user_id: alice.id
        }).save()
      ]);
      return [alice, photos];
    }),
    aliceAndBob: co(function*() {
      var alice, bob, inviter;
      [alice, bob] = (yield [
        new User({
          username: 'alice'
        }).save(),
        new User({
          username: 'bob'
        }).save()
      ]);
      inviter = (yield new Inviter({
        greeting: 'Hello Bob!',
        user_id: alice.id
      }).save());
      yield bob.save({
        inviter_id: inviter.id
      });
      return [alice, bob, inviter];
    })
  };
  before(co(function*() {
    db = init.init();
    return (yield [init.users(), init.photos()]);
  }));
  return describe('BelongsTo', function() {
    describe('plain', function() {
      beforeEach(function() {
        Photo = (function() {
          class Photo extends db.Model {};

          Photo.prototype.tableName = 'photos';

          return Photo;

        }).call(this);
        User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          User.schema([StringField('username'), HasMany(Photo)]);

          return User;

        }).call(this);
        return Photo.schema([StringField('filename'), BelongsTo(User)]);
      });
      afterEach(function() {
        return init.truncate('users', 'photos');
      });
      it('creates accessor', co(function*() {
        var _, alice, photo1;
        [alice, [photo1, _]] = (yield fixtures.alice());
        photo1.user.should.be.a('function');
        yield photo1.load('user');
        photo1.$user.should.be.an.instanceof(User);
        return photo1.$user.username.should.equal(alice.username);
      }));
      it('can assign model', co(function*() {
        var _, alice, bob, photo1;
        [alice, [photo1, _]] = (yield fixtures.alice());
        bob = (yield new User({
          username: 'bob'
        }).save());
        yield photo1.$user.assign(bob);
        photo1 = (yield Photo.forge({
          id: photo1.id
        }).fetch({
          withRelated: 'user'
        }));
        photo1.user_id.should.equal(bob.id);
        return photo1.$user.id.should.equal(bob.id);
      }));
      it('can assign plain object', co(function*() {
        var _, alice, photo1;
        [alice, [photo1, _]] = (yield fixtures.alice());
        yield photo1.$user.assign({
          username: 'bob'
        });
        photo1 = (yield Photo.forge({
          id: photo1.id
        }).fetch({
          withRelated: 'user'
        }));
        return photo1.$user.username.should.equal('bob');
      }));
      it('can assign by id', co(function*() {
        var _, alice, bob, photo1;
        [alice, [photo1, _]] = (yield fixtures.alice());
        bob = (yield new User({
          username: 'bob'
        }).save());
        yield photo1.$user.assign(bob.id);
        photo1 = (yield Photo.forge({
          id: photo1.id
        }).fetch({
          withRelated: 'user'
        }));
        photo1.user_id.should.equal(bob.id);
        return photo1.$user.id.should.equal(bob.id);
      }));
      it('can assign null as a related object', co(function*() {
        var _, alice, photo1;
        [alice, [photo1, _]] = (yield fixtures.alice());
        yield photo1.$user.assign(null);
        photo1 = (yield Photo.forge({
          id: photo1.id
        }).fetch());
        return expect(photo1.user_id).to.be.null;
      }));
      return it('can use custom foreign key and foreign key target', co(function*() {
        var OtherPhoto, _, alice, photo1, photo2;
        OtherPhoto = (function() {
          class OtherPhoto extends db.Model {};

          OtherPhoto.prototype.tableName = 'photos';

          OtherPhoto.schema([
            StringField('filename'),
            StringField('user_name'),
            BelongsTo(User,
            {
              foreignKey: 'user_name',
              foreignKeyTarget: 'username'
            })
          ]);

          return OtherPhoto;

        }).call(this);
        [alice, [photo1, _]] = (yield fixtures.alice());
        photo2 = (yield OtherPhoto.forge({
          id: photo1.id
        }).fetch());
        photo2.user_name = alice.username;
        yield photo2.save();
        yield photo2.load('user');
        return photo2.$user.id.should.equal(alice.id);
      }));
    });
    describe('through', function() {
      before(function() {
        return init.inviters();
      });
      beforeEach(function() {
        Inviter = (function() {
          class Inviter extends db.Model {};

          Inviter.prototype.tableName = 'inviters';

          return Inviter;

        }).call(this);
        User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          User.schema([
            StringField('username'),
            BelongsTo(User,
            {
              name: 'inviter',
              through: Inviter
            })
          ]);

          return User;

        }).call(this);
        return Inviter.schema([StringField('greeting')]);
      });
      afterEach(function() {
        return init.truncate('users', 'inviters');
      });
      return it('can access related model', co(function*() {
        var alice, bob, inviter;
        [alice, bob, inviter] = (yield fixtures.aliceAndBob());
        yield bob.load('inviter');
        bob.$inviter.should.be.an.instanceof(User);
        return bob.$inviter.id.should.equal(alice.id);
      }));
    });
    describe('onDestroy', function() {
      beforeEach(function() {
        Photo = (function() {
          class Photo extends db.Model {};

          Photo.prototype.tableName = 'photos';

          return Photo;

        }).call(this);
        return User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          return User;

        }).call(this);
      });
      afterEach(function() {
        return init.truncate('users', 'photos');
      });
      it('can cascade-destroy dependent models', co(function*() {
        var alice, photo1, photo2;
        Photo.schema([
          BelongsTo(User,
          {
            onDestroy: 'cascade'
          })
        ]);
        [alice, [photo1, photo2]] = (yield fixtures.alice());
        yield photo1.destroy().should.be.fulfilled;
        [alice, photo2] = (yield [
          new User({
            id: alice.id
          }).fetch(),
          new Photo({
            id: photo2.id
          }).fetch()
        ]);
        expect(alice).to.be.null;
        return expect(photo2).not.to.be.null;
      }));
      it('can reject destroy when there is dependent model', co(function*() {
        var _, alice, photo1;
        Photo.schema([
          BelongsTo(User,
          {
            onDestroy: 'reject'
          })
        ]);
        [alice, [photo1, _]] = (yield fixtures.alice());
        yield photo1.destroy().should.be.rejected;
        yield photo1.$user.assign(null);
        return photo1.destroy().should.be.fulfilled;
      }));
      return it('can detach dependend models on destroy', co(function*() {
        var _, alice, photo1;
        Photo.schema([
          // this actually a no-op
          BelongsTo(User,
          {
            onDestroy: 'detach'
          })
        ]);
        [alice, [photo1, _]] = (yield fixtures.alice());
        return (yield photo1.destroy().should.be.fulfilled);
      }));
    });
    return describe('tries to assign correct name to foreign key field', function() {
      beforeEach(function() {
        User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          return User;

        }).call(this);
        return Photo = (function() {
          class Photo extends db.Model {};

          Photo.prototype.tableName = 'photos';

          return Photo;

        }).call(this);
      });
      it('uses <modelName>_id by default', function() {
        Photo.schema([BelongsTo(User)]);
        return Photo.prototype.hasOwnProperty('user_id').should.be.true;
      });
      return it('uses foreign key if defined', function() {
        Photo.schema([
          BelongsTo(User,
          {
            foreignKey: 'userId'
          })
        ]);
        return Photo.prototype.hasOwnProperty('userId').should.be.true;
      });
    });
  });
});
