// Generated by CoffeeScript 2.3.2
var BelongsToMany, Bookshelf, Fields, HasMany, Relations, Schema, StringField, init;

Bookshelf = require('bookshelf');

Schema = require('../../lib/');

init = require('../init');

Fields = require('../../lib/fields');

Relations = require('../../lib/relations');

({StringField} = Fields);

({HasMany, BelongsToMany} = Relations);

describe("Relations", function() {
  var Group, User, db, fixtures;
  this.timeout(3000);
  db = null;
  User = null;
  Group = null;
  fixtures = {
    alice: function() {
      return new User({
        username: 'alice'
      }).save();
    },
    groups: function(...names) {
      return names.map(function(name) {
        return new Group({
          name: name
        }).save();
      });
    },
    connect: function(user, groups) {
      return groups.map(function(group) {
        return db.knex('groups_users').insert({
          user_id: user.id,
          group_id: group.id
        });
      });
    }
  };
  before(co(function*() {
    db = init.init();
    return (yield [init.users(), init.groups()]);
  }));
  return describe('BelongsToMany', function() {
    describe('plain', function() {
      beforeEach(function() {
        Group = (function() {
          class Group extends db.Model {};

          Group.prototype.tableName = 'groups';

          return Group;

        }).call(this);
        User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          User.schema([StringField('username'), BelongsToMany(Group)]);

          return User;

        }).call(this);
        return Group.schema([StringField('name'), BelongsToMany(User)]);
      });
      afterEach(function() {
        return init.truncate('users', 'groups', 'groups_users');
      });
      it('creates accessor', co(function*() {
        var alice, groups;
        [alice, groups] = (yield [fixtures.alice(), fixtures.groups('users')]);
        yield fixtures.connect(alice, groups);
        alice.groups.should.be.a('function');
        yield alice.load('groups');
        alice.$groups.should.be.an.instanceof(db.Collection);
        return alice.$groups.at(0).name.should.equal('users');
      }));
      it('can assign list of models to relation', co(function*() {
        var alice, games, music, users;
        [alice, [users, music, games]] = (yield [fixtures.alice(), fixtures.groups('users', 'music', 'games')]);
        yield fixtures.connect(alice, [users, music]);
        yield alice.$groups.assign([games, music]);
        alice = (yield User.forge({
          id: alice.id
        }).fetch({
          withRelated: 'groups'
        }));
        return alice.$groups.pluck('name').sort().should.deep.equal(['games', 'music']);
      }));
      it('can also assign plain objects and ids', co(function*() {
        var alice, users;
        [alice, [users]] = (yield [fixtures.alice(), fixtures.groups('users')]);
        yield alice.$groups.assign([
          users.id,
          {
            name: 'games'
          }
        ]);
        alice = (yield User.forge({
          id: alice.id
        }).fetch({
          withRelated: 'groups'
        }));
        return alice.$groups.pluck('name').sort().should.deep.equal(['games', 'users']);
      }));
      it('detach all related objects when empty list assigned', co(function*() {
        var alice, users;
        [alice, [users]] = (yield [fixtures.alice(), fixtures.groups('users')]);
        yield fixtures.connect(alice, [users]);
        alice = (yield User.forge({
          id: alice.id
        }).fetch({
          withRelated: 'groups'
        }));
        alice.$groups.length.should.equal(1);
        yield alice.$groups.assign([]);
        alice = (yield User.forge({
          id: alice.id
        }).fetch({
          withRelated: 'groups'
        }));
        return alice.$groups.length.should.equal(0);
      }));
      return it('fixes count method', co(function*() {
        var alice, groups;
        [alice, groups] = (yield [fixtures.alice(), fixtures.groups('users', 'music', 'games')]);
        yield fixtures.connect(alice, groups.slice(0, 2));
        return (yield [alice.$groups.count().should.become(2)]);
      }));
    });
    describe('onDestroy', function() {
      var values;
      ({values} = require('../../lib/utils'));
      beforeEach(function() {
        Group = (function() {
          class Group extends db.Model {};

          Group.prototype.tableName = 'groups';

          return Group;

        }).call(this);
        return User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          return User;

        }).call(this);
      });
      afterEach(function() {
        return init.truncate('users', 'groups', 'groups_users');
      });
      it('blah can cascade-destroy dependent models', co(function*() {
        var alice, aliceId, groups;
        User.schema([
          BelongsToMany(Group,
          {
            onDestroy: 'cascade'
          })
        ]);
        [alice, groups] = (yield [fixtures.alice(), fixtures.groups('users', 'music', 'games')]);
        aliceId = alice.id;
        yield fixtures.connect(alice, groups.slice(0, 2));
        yield alice.$groups.count().should.become(2);
        yield alice.destroy();
        return (yield [
          db.knex('groups_users').where({
            user_id: aliceId
          }).count('*').map(function(a) {
            return parseInt(values(a)[0]);
          }).should.become([0]),
          Group.forge({
            id: groups[2].id
          }).fetch().should.eventually.have.property('id')
        ]);
      }));
      it('can reject destroy when there is any dependent models', co(function*() {
        var alice, groups;
        User.schema([
          BelongsToMany(Group,
          {
            onDestroy: 'reject'
          })
        ]);
        [alice, groups] = (yield [fixtures.alice(), fixtures.groups('users', 'music', 'games')]);
        yield fixtures.connect(alice, groups.slice(0, 2));
        yield alice.destroy().should.be.rejected;
        yield alice.$groups.assign([]);
        return alice.destroy().should.be.fulfilled;
      }));
      return it('can detach dependend models on destroy', co(function*() {
        var alice, aliceId, groups;
        User.schema([
          BelongsToMany(Group,
          {
            onDestroy: 'detach'
          })
        ]);
        [alice, groups] = (yield [fixtures.alice(), fixtures.groups('users', 'music', 'games')]);
        aliceId = alice.id;
        yield fixtures.connect(alice, groups.slice(0, 2));
        yield alice.destroy().should.be.fulfilled;
        return db.knex('groups_users').where({
          user_id: aliceId
        }).count('*').map(function(a) {
          return parseInt(values(a)[0]);
        }).should.become([0]);
      }));
    });
    return describe('events', function() {
      beforeEach(function() {
        Group = (function() {
          class Group extends db.Model {};

          Group.prototype.tableName = 'groups';

          Group.schema([StringField('name')]);

          return Group;

        }).call(this);
        return User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          User.schema([StringField('username'), BelongsToMany(Group)]);

          return User;

        }).call(this);
      });
      afterEach(function() {
        return init.truncate('users', 'groups', 'groups_users');
      });
      return it('fires attaching, attached, detaching and detached events', co(function*() {
        var alice, f, groups, i, len, onAttached, onAttaching, onDetached, onDetaching, ref, results, wheel;
        [alice, groups] = (yield [fixtures.alice(), fixtures.groups('users')]);
        yield fixtures.connect(alice, groups);
        onAttaching = spy();
        onAttached = spy();
        onDetaching = spy();
        onDetached = spy();
        alice.on('attaching', onAttaching);
        alice.on('attached', onAttached);
        alice.on('detaching', onDetaching);
        alice.on('detached', onDetached);
        wheel = (yield new Group({
          name: 'wheel'
        }).save());
        yield alice.$groups.assign([wheel]);
        ref = [onAttaching, onAttached, onDetaching, onDetached];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          f = ref[i];
          results.push(f.should.have.been.called.once());
        }
        return results;
      }));
    });
  });
});
