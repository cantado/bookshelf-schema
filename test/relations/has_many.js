// Generated by CoffeeScript 2.3.2
var BelongsTo, Bookshelf, Fields, HasMany, Relations, Schema, StringField, init;

Bookshelf = require('bookshelf');

Schema = require('../../lib/');

init = require('../init');

Fields = require('../../lib/fields');

Relations = require('../../lib/relations');

({StringField} = Fields);

({HasMany, BelongsTo} = Relations);

describe("Relations", function() {
  var Inviter, Photo, User, db, fixtures;
  this.timeout(3000);
  db = null;
  User = null;
  Photo = null;
  Inviter = null;
  fixtures = {
    alice: co(function*() {
      var alice, photos;
      alice = (yield new User({
        username: 'alice'
      }).save());
      photos = (yield [
        new Photo({
          filename: 'photo1.jpg',
          user_id: alice.id
        }).save(),
        new Photo({
          filename: 'photo2.jpg',
          user_id: alice.id
        }).save()
      ]);
      return [alice, photos];
    }),
    aliceBobAndCharley: co(function*() {
      var alice, bob, charley, inviter1, inviter2;
      [alice, bob, charley] = (yield [
        new User({
          username: 'alice'
        }).save(),
        new User({
          username: 'bob'
        }).save(),
        new User({
          username: 'charley'
        }).save()
      ]);
      [inviter1, inviter2] = (yield [
        new Inviter({
          greeting: 'Hello Bob!',
          user_id: alice.id
        }).save(),
        (yield new Inviter({
          greeting: 'Hi Charley!',
          user_id: alice.id
        }).save())
      ]);
      yield [
        bob.save({
          inviter_id: inviter1.id
        }),
        charley.save({
          inviter_id: inviter2.id
        })
      ];
      return [alice, bob, charley];
    })
  };
  before(co(function*() {
    db = init.init();
    return (yield [init.users(), init.photos()]);
  }));
  return describe('HasMany', function() {
    describe('plain', function() {
      beforeEach(function() {
        Photo = (function() {
          class Photo extends db.Model {};

          Photo.prototype.tableName = 'photos';

          return Photo;

        }).call(this);
        User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          User.schema([StringField('username'), HasMany(Photo)]);

          return User;

        }).call(this);
        return Photo.schema([StringField('filename'), BelongsTo(User)]);
      });
      afterEach(function() {
        return init.truncate('users', 'photos');
      });
      it('create accessor', co(function*() {
        var _, alice;
        [alice, _] = (yield fixtures.alice());
        alice.photos.should.be.a('function');
        yield alice.load('photos');
        alice.$photos.should.be.an.instanceof(db.Collection);
        return alice.$photos.at(0).user_id.should.be.equal(alice.id);
      }));
      it('can assign list of models to relation', co(function*() {
        var alice, bob, photo1, photo2, photo3;
        [alice, [photo1, photo2]] = (yield fixtures.alice());
        bob = (yield new User({
          username: 'bob'
        }).save());
        photo3 = (yield new Photo({
          filename: 'photo3.jpg',
          user_id: bob.id
        }).save());
        yield bob.$photos.assign([photo1]);
        bob = (yield User.forge({
          id: bob.id
        }).fetch({
          withRelated: 'photos'
        }));
        alice = (yield User.forge({
          id: alice.id
        }).fetch({
          withRelated: 'photos'
        }));
        bob.$photos.length.should.equal(1);
        bob.$photos.at(0).id.should.equal(photo1.id);
        alice.$photos.length.should.equal(1);
        return alice.$photos.at(0).id.should.equal(photo2.id);
      }));
      it('can also assign plain objects and ids', co(function*() {
        var alice, bob, photo1, photo2;
        [alice, [photo1, photo2]] = (yield fixtures.alice());
        bob = (yield new User({
          username: 'bob'
        }).save());
        yield bob.$photos.assign([
          {
            filename: 'photo3.jpg'
          },
          photo1.id
        ]);
        [bob, alice] = (yield [
          User.forge({
            id: bob.id
          }).fetch({
            withRelated: 'photos'
          }),
          User.forge({
            id: alice.id
          }).fetch({
            withRelated: 'photos'
          })
        ]);
        bob.$photos.length.should.equal(2);
        bob.$photos.pluck('filename').sort().should.deep.equal(['photo1.jpg', 'photo3.jpg']);
        alice.$photos.length.should.equal(1);
        return alice.$photos.pluck('filename').should.deep.equal(['photo2.jpg']);
      }));
      it('can attach plain objects and ids', co(function*() {
        var alice, bob, photo1, photo2;
        [alice, [photo1, photo2]] = (yield fixtures.alice());
        bob = (yield new User({
          username: 'bob'
        }).save());
        yield bob.$photos.attach([
          {
            filename: 'photo3.jpg'
          },
          photo1.id
        ]);
        [bob, alice] = (yield [
          User.forge({
            id: bob.id
          }).fetch({
            withRelated: 'photos'
          }),
          User.forge({
            id: alice.id
          }).fetch({
            withRelated: 'photos'
          })
        ]);
        bob.$photos.length.should.equal(2);
        bob.$photos.pluck('filename').sort().should.deep.equal(['photo1.jpg', 'photo3.jpg']);
        alice.$photos.length.should.equal(1);
        return alice.$photos.pluck('filename').should.deep.equal(['photo2.jpg']);
      }));
      it('detach all related objects when empty list assigned', co(function*() {
        var _, alice;
        [alice, _] = (yield fixtures.alice());
        yield Photo.where('user_id', '=', alice.id).count().then(parseInt).should.become(2);
        yield alice.$photos.assign([]);
        return Photo.where('user_id', '=', alice.id).count().then(parseInt).should.become(0);
      }));
      return it('fixes count method', co(function*() {
        var alice, otherPhoto, photos;
        [alice, photos] = (yield fixtures.alice());
        otherPhoto = (yield new Photo({
          filename: 'photo3.jpg'
        }).save());
        return (yield [alice.$photos.count().should.become(photos.length)]);
      }));
    });
    describe('through', function() {
      before(function() {
        return init.inviters();
      });
      beforeEach(function() {
        Inviter = (function() {
          class Inviter extends db.Model {};

          Inviter.prototype.tableName = 'inviters';

          return Inviter;

        }).call(this);
        User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          User.schema([
            StringField('username'),
            HasMany(User,
            {
              name: 'invited',
              through: Inviter
            })
          ]);

          return User;

        }).call(this);
        return Inviter.schema([StringField('greeting')]);
      });
      afterEach(function() {
        return init.truncate('users', 'inviters');
      });
      return it('can access related model', co(function*() {
        var alice, bob, charley;
        [alice, bob, charley] = (yield fixtures.aliceBobAndCharley());
        yield alice.load('invited');
        alice.$invited.should.be.an.instanceof(db.Collection);
        return alice.$invited.pluck('username').sort().should.deep.equal(['bob', 'charley']);
      }));
    });
    describe('onDestroy', function() {
      beforeEach(function() {
        User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          return User;

        }).call(this);
        return Photo = (function() {
          class Photo extends db.Model {};

          Photo.prototype.tableName = 'photos';

          Photo.schema([StringField('filename'), BelongsTo(User)]);

          return Photo;

        }).call(this);
      });
      afterEach(function() {
        return init.truncate('users', 'photos');
      });
      it('can cascade-destroy dependent models', co(function*() {
        var alice, aliceId, photo1, photo2, photo3;
        User.schema([
          HasMany(Photo,
          {
            onDestroy: 'cascade'
          })
        ]);
        [alice, [photo1, photo2]] = (yield fixtures.alice());
        photo3 = (yield new Photo({
          filename: 'photo3.jpg',
          user_id: null
        }).save());
        yield alice.$photos.count().should.become(2);
        aliceId = alice.id;
        yield alice.destroy().should.be.fulfilled;
        return (yield [Photo.where('user_id', '=', aliceId).count().then(parseInt).should.become(0), Photo.where('id', '=', photo3.id).count().then(parseInt).should.become(1)]);
      }));
      it('can reject destroy when there is any dependent models', co(function*() {
        var _, alice;
        User.schema([
          HasMany(Photo,
          {
            onDestroy: 'reject'
          })
        ]);
        [alice, _] = (yield fixtures.alice());
        yield alice.destroy().should.be.rejected;
        yield alice.$photos.assign([]);
        return alice.destroy().should.be.fulfilled;
      }));
      return it('can detach dependend models on destroy', co(function*() {
        var alice, photo, photoIds, photos;
        User.schema([
          HasMany(Photo,
          {
            onDestroy: 'detach'
          })
        ]);
        [alice, photos] = (yield fixtures.alice());
        photoIds = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = photos.length; i < len; i++) {
            photo = photos[i];
            results.push(photo.id);
          }
          return results;
        })();
        yield alice.destroy().should.be.fulfilled;
        return Photo.collection().query(function(qb) {
          return qb.whereIn('id', photoIds);
        }).fetch().then(function(c) {
          return c.pluck('user_id');
        }).should.become([null, null]);
      }));
    });
    return describe('events', function() {
      beforeEach(function() {
        Photo = (function() {
          class Photo extends db.Model {};

          Photo.prototype.tableName = 'photos';

          Photo.schema([StringField('filename')]);

          return Photo;

        }).call(this);
        return User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          User.schema([StringField('username'), HasMany(Photo)]);

          return User;

        }).call(this);
      });
      afterEach(function() {
        return init.truncate('users', 'photos');
      });
      return it('fires attaching, attached, detaching and detached events', co(function*() {
        var _, alice, f, i, len, onAttached, onAttaching, onDetached, onDetaching, photo3, ref, results;
        [alice, _] = (yield fixtures.alice());
        onAttaching = spy();
        onAttached = spy();
        onDetaching = spy();
        onDetached = spy();
        alice.on('attaching', onAttaching);
        alice.on('attached', onAttached);
        alice.on('detaching', onDetaching);
        alice.on('detached', onDetached);
        photo3 = (yield new Photo({
          filename: 'photo3.jpg'
        }).save());
        yield alice.$photos.assign([photo3]);
        ref = [onAttaching, onAttached, onDetaching, onDetached];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          f = ref[i];
          results.push(f.should.have.been.called.once());
        }
        return results;
      }));
    });
  });
});
