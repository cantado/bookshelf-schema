// Generated by CoffeeScript 2.3.2
var Bookshelf, Fields, MorphMany, MorphTo, Relations, Schema, StringField, init;

Bookshelf = require('bookshelf');

Schema = require('../../lib/');

init = require('../init');

Fields = require('../../lib/fields');

Relations = require('../../lib/relations');

({StringField} = Fields);

({MorphMany, MorphTo} = Relations);

describe("Relations", function() {
  var Tag, User, db, fixtures;
  this.timeout(3000);
  db = null;
  User = null;
  Tag = null;
  fixtures = {
    alice: co(function*() {
      var alice, tags;
      alice = (yield new User({
        username: 'alice'
      }).save());
      tags = (yield [
        new Tag({
          name: 'girl',
          tagable_id: alice.id,
          tagable_type: 'users'
        }).save(),
        new Tag({
          name: 'redhead',
          tagable_id: alice.id,
          tagable_type: 'users'
        }).save()
      ]);
      return [alice, tags];
    })
  };
  before(co(function*() {
    db = init.init();
    return (yield [init.users(), init.tags()]);
  }));
  return describe('MorphMany', function() {
    describe('plain', function() {
      beforeEach(function() {
        Tag = (function() {
          class Tag extends db.Model {};

          Tag.prototype.tableName = 'tags';

          return Tag;

        }).call(this);
        User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          User.schema([StringField('username'), MorphMany(Tag, 'tagable')]);

          return User;

        }).call(this);
        return Tag.schema([StringField('name'), MorphTo('tagable', [User])]);
      });
      afterEach(function() {
        return init.truncate('users', 'tags');
      });
      it('creates accessor', co(function*() {
        var _, alice;
        [alice, _] = (yield fixtures.alice());
        alice.tags.should.be.a('function');
        yield alice.load('tags');
        return alice.$tags.should.be.an.instanceof(db.Collection);
      }));
      it('can assign list of models to relation', co(function*() {
        var alice, bob, boy, girl, redhead;
        [alice, [girl, redhead]] = (yield fixtures.alice());
        bob = (yield new User({
          username: 'bob'
        }).save());
        boy = (yield new Tag({
          name: 'boy'
        }).save());
        yield bob.$tags.assign([boy, redhead]);
        [bob, alice] = (yield [
          User.forge({
            id: bob.id
          }).fetch({
            withRelated: 'tags'
          }),
          User.forge({
            id: alice.id
          }).fetch({
            withRelated: 'tags'
          })
        ]);
        bob.$tags.length.should.equal(2);
        bob.$tags.pluck('name').sort().should.deep.equal(['boy', 'redhead']);
        alice.$tags.length.should.equal(1);
        return alice.$tags.at(0).name.should.equal('girl');
      }));
      it('can also assign plain objects and ids', co(function*() {
        var alice, bob, girl, redhead;
        [alice, [girl, redhead]] = (yield fixtures.alice());
        bob = (yield new User({
          username: 'bob'
        }).save());
        yield bob.$tags.assign([
          {
            name: 'boy'
          },
          redhead.id
        ]);
        [bob, alice] = (yield [
          User.forge({
            id: bob.id
          }).fetch({
            withRelated: 'tags'
          }),
          User.forge({
            id: alice.id
          }).fetch({
            withRelated: 'tags'
          })
        ]);
        bob.$tags.length.should.equal(2);
        return bob.$tags.pluck('name').sort().should.deep.equal(['boy', 'redhead']);
      }));
      it('detach all related objects when empty list assigned', co(function*() {
        var _, alice;
        [alice, _] = (yield fixtures.alice());
        yield Tag.where({
          tagable_id: alice.id,
          tagable_type: 'users'
        }).count().then(parseInt).should.become(2);
        yield alice.$tags.assign([]);
        return Tag.where({
          tagable_id: alice.id,
          tagable_type: 'users'
        }).count().then(parseInt).should.become(0);
      }));
      return it('fixes count method', co(function*() {
        var alice, boy, tags;
        [alice, tags] = (yield fixtures.alice());
        boy = (yield new Tag({
          name: 'boy'
        }).save());
        return (yield [alice.$tags.count().should.become(2)]);
      }));
    });
    return describe('onDestroy', function() {
      beforeEach(function() {
        User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          return User;

        }).call(this);
        return Tag = (function() {
          class Tag extends db.Model {};

          Tag.prototype.tableName = 'tags';

          return Tag;

        }).call(this);
      });
      afterEach(function() {
        return init.truncate('users', 'tags');
      });
      it('can cascade-destroy dependent models', co(function*() {
        var alice, aliceId, boy, tags;
        User.schema([
          MorphMany(Tag,
          'tagable',
          {
            onDestroy: 'cascade'
          })
        ]);
        [alice, tags] = (yield fixtures.alice());
        boy = (yield new Tag({
          name: 'boy'
        }).save());
        yield alice.$tags.count().should.become(2);
        aliceId = alice.id;
        yield alice.destroy().should.be.fulfilled;
        return (yield [
          Tag.where({
            tagable_id: aliceId,
            tagable_type: 'users'
          }).count().then(parseInt).should.become(0),
          expect(new Tag({
            id: boy.id
          }).fetch()).not.to.be.null
        ]);
      }));
      it('can reject destroy when there is any dependent models', co(function*() {
        var alice, tags;
        User.schema([
          MorphMany(Tag,
          'tagable',
          {
            onDestroy: 'reject'
          })
        ]);
        [alice, tags] = (yield fixtures.alice());
        yield alice.destroy().should.be.rejected;
        yield alice.$tags.assign([]);
        return alice.destroy().should.be.fulfilled;
      }));
      return it('can detach dependend models on destroy', co(function*() {
        var alice, tag, tagIds, tags;
        User.schema([
          MorphMany(Tag,
          'tagable',
          {
            onDestroy: 'detach'
          })
        ]);
        [alice, tags] = (yield fixtures.alice());
        tagIds = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            results.push(tag.id);
          }
          return results;
        })();
        yield alice.destroy().should.be.fulfilled;
        return Tag.collection().query(function(qb) {
          return qb.whereIn('id', tagIds);
        }).fetch().then(function(c) {
          return c.pluck('tagable_id');
        }).should.become([null, null]);
      }));
    });
  });
});
