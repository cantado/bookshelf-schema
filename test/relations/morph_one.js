// Generated by CoffeeScript 2.3.2
var Bookshelf, Fields, MorphOne, MorphTo, Relations, Schema, StringField, init;

Bookshelf = require('bookshelf');

Schema = require('../../src/');

init = require('../init');

Fields = require('../../src/fields');

Relations = require('../../src/relations');

({StringField} = Fields);

({MorphOne, MorphTo} = Relations);

describe("Relations", function() {
  var Tag, User, db, fixtures;
  this.timeout(3000);
  db = null;
  User = null;
  Tag = null;
  fixtures = {
    alice: co(function*() {
      var alice, tag;
      alice = (yield new User({
        username: 'alice'
      }).save());
      tag = (yield new Tag({
        name: 'girl',
        tagable_id: alice.id,
        tagable_type: 'users'
      }).save());
      return [alice, tag];
    })
  };
  before(co(function*() {
    db = init.init();
    return (yield [init.users(), init.tags()]);
  }));
  return describe('MorphOne', function() {
    describe('plain', function() {
      var ensureAssigned;
      beforeEach(function() {
        User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          return User;

        }).call(this);
        Tag = (function() {
          class Tag extends db.Model {};

          Tag.prototype.tableName = 'tags';

          Tag.schema([StringField('name'), MorphTo('tagable', User)]);

          return Tag;

        }).call(this);
        return User.schema([StringField('username'), MorphOne(Tag, 'tagable')]);
      });
      afterEach(function() {
        return init.truncate('users', 'tags');
      });
      it('creates accessor', co(function*() {
        var alice, tag;
        [alice, tag] = (yield fixtures.alice());
        alice.tag.should.be.a('function');
        yield alice.load('tag');
        alice.$tag.should.be.an.instanceof(Tag);
        return alice.$tag.name.should.equal(tag.name);
      }));
      ensureAssigned = function*(newTag, name) {
        var alice, tag;
        if (name == null) {
          name = newTag.name;
        }
        [alice, tag] = (yield fixtures.alice());
        yield alice.$tag.assign(newTag);
        [alice, tag] = (yield [
          User.forge({
            id: alice.id
          }).fetch({
            withRelated: 'tag'
          }),
          Tag.forge({
            id: tag.id
          }).fetch()
        ]);
        alice.$tag.name.should.equal(name);
        expect(tag.get('tagable_id')).to.be.null;
        return expect(tag.get('tagable_type')).to.be.null;
      };
      it('can assign model', co(function*() {
        var tag2;
        tag2 = (yield new Tag({
          name: 'redhead'
        }).save());
        return (yield ensureAssigned(tag2));
      }));
      it('can assign plain objects', function() {
        return ensureAssigned({
          name: 'redhead'
        });
      });
      return it('can assign by id', co(function*() {
        var tag2;
        tag2 = (yield new Tag({
          name: 'redhead'
        }).save());
        return (yield ensureAssigned(tag2.id, tag2.name));
      }));
    });
    return describe('onDestroy', function() {
      beforeEach(function() {
        User = (function() {
          class User extends db.Model {};

          User.prototype.tableName = 'users';

          return User;

        }).call(this);
        return Tag = (function() {
          class Tag extends db.Model {};

          Tag.prototype.tableName = 'tags';

          return Tag;

        }).call(this);
      });
      afterEach(function() {
        return init.truncate('users', 'tags');
      });
      it('can cascade-destroy dependent models', co(function*() {
        var alice, bob, tag;
        Tag.schema([
          MorphTo('tagable',
          [User],
          {
            onDestroy: 'cascade'
          })
        ]);
        [alice, tag] = (yield fixtures.alice());
        bob = (yield new User({
          username: 'bob'
        }).save());
        yield tag.destroy().should.be.fulfilled;
        [alice, bob] = (yield [
          new User({
            id: alice.id
          }).fetch(),
          new User({
            id: bob.id
          }).fetch()
        ]);
        expect(alice).to.be.null;
        return expect(bob).not.to.be.null;
      }));
      it('can reject destroy when there id dependent model', co(function*() {
        var _, tag;
        Tag.schema([
          MorphTo('tagable',
          [User],
          {
            onDestroy: 'reject'
          })
        ]);
        [_, tag] = (yield fixtures.alice());
        yield tag.destroy().should.be.rejected;
        yield tag.$tagable.assign(null);
        return tag.destroy().should.be.fulfilled;
      }));
      return it('can detach dependent models on destroy', co(function*() {
        var _, tag;
        Tag.schema([
          // this actually a no-op
          MorphTo('tagable',
          [Tag],
          {
            onDestroy: 'detach'
          })
        ]);
        [_, tag] = (yield fixtures.alice());
        return (yield tag.destroy().should.be.fulfilled);
      }));
    });
  });
});
